#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck disable=SC1091
source "$SCRIPT_DIR/px-env"

python - "$@" <<'PY'
from __future__ import annotations

import datetime as dt
import json
import os
from ftplib import FTP, all_errors as FTP_ERRORS
from io import BytesIO
from typing import Any, Dict, Iterable, List, Tuple
from urllib import error as url_error
from urllib import parse as url_parse
from urllib import request as url_request

from pxh.logging import log_event
from pxh.state import update_session

DEFAULT_PRODUCT = os.environ.get("PX_WEATHER_PRODUCT", "IDT60801")
DEFAULT_STATION = os.environ.get("PX_WEATHER_STATION", "95977")
DEFAULT_TIMEOUT = float(os.environ.get("PX_WEATHER_TIMEOUT", "10"))
DEFAULT_HTTPS = f"https://reg.bom.gov.au/fwo/{DEFAULT_PRODUCT}/{DEFAULT_PRODUCT}.{DEFAULT_STATION}.json"
DEFAULT_FTP = f"ftp://ftp.bom.gov.au/anon/gen/fwo/{DEFAULT_PRODUCT}.{DEFAULT_STATION}.json"
DEFAULT_ALT = f"https://www.bom.gov.au/fwo/{DEFAULT_PRODUCT}/{DEFAULT_PRODUCT}.{DEFAULT_STATION}.json"

COMMON_ERRORS = (
    url_error.URLError,
    url_error.HTTPError,
    TimeoutError,
    json.JSONDecodeError,
    ValueError,
    OSError,
) + FTP_ERRORS


def candidate_urls() -> List[str]:
    override = os.environ.get("PX_WEATHER_URL")
    if override:
        return [override.strip()]
    urls = [DEFAULT_HTTPS, DEFAULT_FTP, DEFAULT_ALT]
    seen: set[str] = set()
    ordered: List[str] = []
    for url in urls:
        if url and url not in seen:
            ordered.append(url)
            seen.add(url)
    return ordered


def fetch_http(url: str, timeout: float) -> Dict[str, Any]:
    request = url_request.Request(url, headers={"User-Agent": "PiCarX-Helper/1.0"})
    with url_request.urlopen(request, timeout=timeout) as response:
        charset = response.headers.get_content_charset("utf-8") or "utf-8"
        data = response.read().decode(charset)
    return json.loads(data)


def fetch_ftp(url: str, timeout: float) -> Dict[str, Any]:
    parsed = url_parse.urlparse(url)
    path = parsed.path.lstrip("/")
    if not path:
        raise ValueError("FTP URL missing path")
    buffer = BytesIO()
    with FTP(parsed.hostname, timeout=timeout) as ftp:
        ftp.login()
        ftp.cwd("anon/gen/fwo")
        ftp.retrbinary(f"RETR {path}", buffer.write)
    return json.loads(buffer.getvalue().decode("utf-8"))


def try_fetch(urls: Iterable[str], timeout: float) -> Tuple[Dict[str, Any] | None, str | None, List[Dict[str, str]]]:
    errors: List[Dict[str, str]] = []
    for url in urls:
        if not url:
            continue
        parsed = url_parse.urlparse(url)
        try:
            if parsed.scheme in {"http", "https"}:
                payload = fetch_http(url, timeout)
            elif parsed.scheme == "ftp":
                payload = fetch_ftp(url, timeout)
            else:
                raise ValueError(f"unsupported scheme: {parsed.scheme}")
        except COMMON_ERRORS as exc:  # type: ignore[arg-type]
            errors.append({"url": url, "detail": str(exc)})
            continue
        return payload, url, errors
    return None, None, errors


def build_success_payload(source_url: str, raw: Dict[str, Any]) -> Dict[str, Any]:
    obs = raw.get("observations", {}).get("data", [])
    if not obs:
        return {
            "status": "error",
            "url": source_url,
            "detail": "no observations",
            "summary": "Weather feed returned no observations.",
        }
    latest = obs[0]
    station = latest.get("name") or "Unknown station"
    temp = latest.get("air_temp")
    feels = latest.get("apparent_t")
    wind_dir = latest.get("wind_dir") or "calm"
    wind = latest.get("wind_spd_kmh")
    gust = latest.get("gust_kmh")
    humidity = latest.get("rel_hum")
    rain = latest.get("rain_trace")
    timestamp = latest.get("aifstime_utc")

    details: List[str] = []
    if temp is not None:
        details.append(f"{temp}°C")
    if feels is not None:
        details.append(f"feels like {feels}°C")
    if wind is not None:
        details.append(f"wind {wind_dir} {wind} km/h")
    if gust:
        details.append(f"gusting to {gust} km/h")
    if humidity is not None:
        details.append(f"humidity {humidity}%")
    if rain is not None and rain not in ("0", "0.0", 0, 0.0):
        details.append(f"rain last 24h {rain} mm")
    if timestamp:
        details.append(f"observed at {timestamp} UTC")
    if details:
        summary = f"Weather at {station}: " + ", ".join(details)
    else:
        summary = f"Weather at {station}."

    return {
        "status": "ok",
        "url": source_url,
        "station": station,
        "lat": latest.get("lat"),
        "lon": latest.get("lon"),
        "temp_C": temp,
        "apparent_temp_C": feels,
        "wind_dir": latest.get("wind_dir"),
        "wind_kmh": wind,
        "gust_kmh": gust,
        "humidity_pct": humidity,
        "rain_24h_mm": rain,
        "timestamp_utc": timestamp,
        "fetched_utc": dt.datetime.utcnow().isoformat(timespec="seconds") + "Z",
        "summary": summary,
    }


def error_summary(payload: Dict[str, Any]) -> str:
    status = payload.get("status")
    if status == "dry-run":
        urls = payload.get("urls", [])
        return "Dry-run: would fetch weather from " + ", ".join(urls)
    errors = payload.get("errors")
    if errors:
        details = "; ".join(f"{e['url']}: {e['detail']}" for e in errors)
        return f"Weather fetch failed: {details}"
    return payload.get("detail", "Weather fetch failed")


def main() -> int:
    dry_mode = os.environ.get("PX_DRY", "1") != "0"
    urls = candidate_urls()

    if dry_mode:
        payload = {
            "status": "dry-run",
            "urls": urls,
            "detail": "network request skipped",
        }
    else:
        raw, used_url, errors = try_fetch(urls, DEFAULT_TIMEOUT)
        if raw and used_url:
            payload = build_success_payload(used_url, raw)
        else:
            payload = {
                "status": "error",
                "urls": urls,
                "errors": errors,
                "summary": error_summary({"errors": errors, "status": "error"}),
            }

    if "summary" not in payload:
        payload["summary"] = error_summary(payload)

    update_session(
        fields={
            "last_action": "tool_weather",
            "last_weather": payload,
        },
        history_entry={
            "event": "weather",
            "status": payload.get("status"),
        },
    )

    log_event("weather", payload)
    print(json.dumps(payload, ensure_ascii=False))

    return 0 if payload.get("status") in {"ok", "dry-run"} else 1


if __name__ == "__main__":
    raise SystemExit(main())
PY
