#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
# shellcheck disable=SC1091
source "$SCRIPT_DIR/px-env"

python - "$@" <<'PY'
from __future__ import annotations

import argparse
import json
import os
import re
import subprocess
import tempfile
import time
import shutil
from pathlib import Path
from typing import Any, Dict, List, Optional

from pxh.logging import log_event
from pxh.state import update_session


def run_tool(command: List[str], extra_env: Dict[str, str] | None = None) -> Dict[str, Any]:
    env = os.environ.copy()
    env.setdefault("PROJECT_ROOT", os.environ["PROJECT_ROOT"])
    env.setdefault("PX_BYPASS_SUDO", os.environ.get("PX_BYPASS_SUDO", "0"))
    if extra_env:
        env.update(extra_env)
    result = subprocess.run(
        command,
        capture_output=True,
        text=True,
        check=False,
        env=env,
    )
    payload: Dict[str, Any] = {
        "cmd": " ".join(command),
        "returncode": result.returncode,
        "stdout": result.stdout[-2048:],
        "stderr": result.stderr[-2048:],
    }
    try:
        payload["data"] = json.loads(result.stdout.splitlines()[-1])
    except Exception:
        payload["data"] = None
    return payload


def announce(message: str) -> None:
    run_tool(["bin/tool-voice"], {"PX_TEXT": message, "PX_DRY": "0"})


def main() -> int:
    parser = argparse.ArgumentParser(description="PiCar-X diagnostics sweep")
    parser.add_argument("--no-motion", action="store_true", help="Skip motion tests even if not in dry-run")
    parser.add_argument("--short", action="store_true", help="Skip weather and camera checks for speed")
    mode_group = parser.add_mutually_exclusive_group()
    mode_group.add_argument("--dry-run", dest="force_dry", action="store_true", help="Force dry-run mode regardless of PX_DRY")
    mode_group.add_argument("--live", dest="force_live", action="store_true", help="Force live mode regardless of PX_DRY")
    args = parser.parse_args()

    current_dry = os.environ.get("PX_DRY")
    if args.force_dry:
        os.environ["PX_DRY"] = "1"
    elif args.force_live:
        os.environ["PX_DRY"] = "0"
    elif current_dry is None:
        os.environ["PX_DRY"] = "0"

    dry_mode = os.environ.get("PX_DRY", "1") != "0"
    results: Dict[str, Any] = {
        "status": "ok",
        "dry": dry_mode,
        "checks": [],
    }
    telemetry: Dict[str, Any] = {
        "mode": "dry-run" if dry_mode else "live",
    }

    announce(f"Starting diagnostics {'dry run' if dry_mode else 'live'}")

    announce("Running status check")
    status_info = run_tool(["bin/tool-status"], {"PX_DRY": "1" if dry_mode else "0"})
    announce("Status check complete")
    results["checks"].append({"name": "status", **status_info})
    status_payload = status_info.get("data", {}) or {}
    battery_ok = status_payload.get("battery_ok")
    battery_pct: Optional[float] = status_payload.get("battery_pct")
    telemetry["battery_ok"] = battery_ok
    telemetry["battery_pct"] = battery_pct
    stdout_status = status_info.get("stdout", "")
    voltage_match = re.search(r"Battery estimate:\s*([0-9.]+)\s*V", stdout_status)
    if voltage_match:
        try:
            telemetry["battery_voltage"] = float(voltage_match.group(1))
        except ValueError:
            telemetry["battery_voltage"] = voltage_match.group(1)
    if battery_ok is False:
        results["status"] = "warn"
        results.setdefault("warnings", []).append("battery low")

    sensor_check = {"name": "sensors", "status": "ok"}
    stdout = stdout_status
    distance = None
    match = re.search(r"Ultrasonic distance: ([\-\d.]+)", stdout)
    if match:
        try:
            distance = float(match.group(1))
        except ValueError:
            distance = None
    grayscale_match = re.search(r"Grayscale readings: \[(.*?)\]", stdout)
    if grayscale_match:
        try:
            sensor_check["grayscale"] = [float(part.strip()) for part in grayscale_match.group(1).split(",")]
        except ValueError:
            sensor_check["grayscale"] = None
    sensor_check["distance_cm"] = distance
    if distance is None:
        sensor_check["status"] = "warn"
    sensor_check["raw"] = stdout[-512:]
    results["checks"].append(sensor_check)
    telemetry["ultrasonic_cm"] = distance
    if "grayscale" in sensor_check:
        telemetry["grayscale"] = sensor_check["grayscale"]
    if distance is not None:
        announce(f"Ultrasonic {distance:.0f} centimeters")
    else:
        announce("Ultrasonic sensor unavailable")

    if not args.short:
        announce("Checking weather feed")
        weather_info = run_tool(["bin/tool-weather"], {"PX_DRY": "1"})
        weather_info["name"] = "weather"
        results["checks"].append(weather_info)
        if weather_info.get("returncode") == 0:
            announce("Weather check succeeded")
        else:
            announce("Weather check failed")

    do_motion = not (dry_mode or args.no_motion)
    motion_check = None
    if do_motion:
        announce("Testing motors with circle routine")
        motion_env = {"PX_DRY": "1" if dry_mode else "0", "PX_SPEED": "25", "PX_DURATION": "2"}
        motion_check = run_tool(["bin/tool-circle"], motion_env)
        motion_check["name"] = "circle"
        results["checks"].append(motion_check)
        telemetry["motors_ok"] = motion_check.get("returncode") == 0
        if motion_check["returncode"] != 0:
            results["status"] = "error"
            announce("Motor test failed")
        else:
            announce("Motor test passed")

    camera_check = None
    if not dry_mode and not args.short:
        announce("Capturing camera frame")
        image_path = None
        try:
            with tempfile.NamedTemporaryFile(suffix=".jpg", delete=False) as tmp:
                image_path = Path(tmp.name)
            camera_check = run_tool(["rpicam-still", "--nopreview", "-t", "200", "-o", str(image_path)])
            camera_check["name"] = "camera"
            if camera_check["returncode"] == 0 and image_path.exists():
                camera_check["status"] = "ok"
                camera_check["file"] = str(image_path)
                announce("Camera capture successful")
            else:
                camera_check["status"] = "error"
                results["status"] = "warn"
                results.setdefault("warnings", []).append("camera capture failed")
                announce("Camera capture failed")
            results["checks"].append(camera_check)
            telemetry["camera_ok"] = camera_check.get("returncode") == 0
        finally:
            if image_path and image_path.exists():
                try:
                    image_path.unlink()
                except OSError:
                    pass

    speaker_check = run_tool(["bin/tool-voice"], {"PX_TEXT": "Speaker diagnostic", "PX_DRY": "0"})
    speaker_check["name"] = "speaker"
    results["checks"].append(speaker_check)
    telemetry["speaker_ok"] = speaker_check.get("returncode") == 0
    if not dry_mode and speaker_check.get("returncode") != 0:
        results.setdefault("warnings", []).append("speaker test failed")
        results["status"] = "warn"

    mic_check = {"name": "microphone", "status": "dry-run" if dry_mode else "skip"}
    if not dry_mode:
        mic_path = None
        try:
            if shutil.which("arecord"):
                with tempfile.NamedTemporaryFile(suffix=".wav", delete=False) as tmp:
                    mic_path = Path(tmp.name)
                cmd = ["arecord", "-d", "2", "-f", "cd", str(mic_path)]
                proc = subprocess.run(cmd, capture_output=True, text=True)
                mic_check["cmd"] = " ".join(cmd)
                mic_check["returncode"] = proc.returncode
                if proc.returncode == 0 and mic_path.exists() and mic_path.stat().st_size > 0:
                    mic_check["status"] = "ok"
                    mic_check["file"] = str(mic_path)
                else:
                    mic_check["status"] = "warn"
                    mic_check["stderr"] = proc.stderr[-512:]
                    results.setdefault("warnings", []).append("microphone test failed")
                    results["status"] = "warn"
            else:
                mic_check["status"] = "unavailable"
                results.setdefault("warnings", []).append("arecord not found")
                results["status"] = "warn"
        finally:
            if mic_path and mic_path.exists():
                try:
                    mic_path.unlink()
                except OSError:
                    pass
    results["checks"].append(mic_check)

    telemetry["microphone_status"] = mic_check.get("status")
    voice_summary = "Diagnostics complete: "
    voice_bits = []
    if battery_ok is False:
        voice_bits.append("battery below threshold")
    elif battery_ok:
        voice_bits.append("battery is healthy")
    if distance is not None:
        voice_bits.append(f"range {distance:.0f} cm")
    elif sensor_check["status"] != "ok":
        voice_bits.append("ultrasonic unavailable")
    if motion_check is not None:
        if motion_check["returncode"] == 0:
            voice_bits.append("motors responsive")
        else:
            voice_bits.append("motor test failed")
    if camera_check is not None:
        if camera_check.get("returncode") == 0:
            voice_bits.append("camera capture OK")
        else:
            voice_bits.append("camera capture failed")
    if speaker_check.get("returncode") != 0:
        voice_bits.append("speaker test failed")
    if mic_check.get("status") == "ok":
        voice_bits.append("microphone ok")
    elif mic_check.get("status") not in {"dry-run", "skip"}:
        voice_bits.append("microphone issue")
    if not voice_bits:
        voice_bits.append("see logs")
    voice_summary += ", ".join(voice_bits)

    voice_info = run_tool(["bin/tool-voice"], {"PX_TEXT": voice_summary, "PX_DRY": "0"})
    voice_info["name"] = "voice"
    results["checks"].append(voice_info)
    telemetry["voice_summary"] = voice_summary

    results["telemetry"] = telemetry
    log_event("diagnostics", results)
    log_event("health", {"status": results["status"], "dry": dry_mode, "telemetry": telemetry})
    update_session(history_entry={"event": "diagnostics", "status": results["status"]})
    print(json.dumps(results, ensure_ascii=False))
    return 0 if results["status"] != "error" else 1


if __name__ == "__main__":
    raise SystemExit(main())
PY
